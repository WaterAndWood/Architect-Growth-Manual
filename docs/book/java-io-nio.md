
# Java中的IO

## IO模型

明确两个概念：

1. **阻塞**：指用户空间程序的执行状态，需要等待内核IO操作完成之后才能返回用户空间执行。
2. **同步**：一种用户空间与内核空间的IO发起方式。
   - **同步**：用户空间主动发起IO请求，内核空间被动接受
   - **异步**：内核空间主动发起IO请求，用户空间被动接受 

### 同步阻塞IO（Blocking IO）

1. 传统的IO模型，java中默认创建socket都是阻塞的
2. 用户空间等待内核空间完成数据的准备和处理，期间一直阻塞
3. 等待期间释放CPU
4. 内核将数据复制到用户线程之后，返回状态给用户线程，才能解除阻塞状态 

<div align=center>

![1592478336976.png](..\images\1592478336976.png)

</div>

### 同步非阻塞IO（Non-blocking IO）

1. 用户空间不需要等待内核空间完成数据的处理，会马上收到一个结果
2. 结果是error时用户空间会再次IO请求，一旦内核中完成数据准备，并且接收到用户线程IO请求时，就会把数据复制到用户空间
3. 非阻塞IO不释放CPU（导致CPU占用率过高）

<div align=center>

![1592478379066.png](..\images\1592478379066.png)

</div>


### IO多路复用（IO Multiplexing）

1. 经典的Reactor反应器设计模式，有时也称为异步阻塞IO, Java中的Selector选择器和Linux中的epoll都是这种模型。
2. Java NIO 实际上就是多路复用 IO。
3. 线程不断轮询多个socket的状态，只有socket真正有读写事件时才会实际触发IO读写。
4. 优点：减少了资源占用，效率高（轮询每个 socket 状态是内核在进行的）
5. Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。
6. 缺点：对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 

<div align=center>

![1592478418201.png](..\images\1592478418201.png)

</div>


### 信号驱动 IO 模型 

在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。 

### 异步IO（Asynchronous IO）

1. 一种回调模式
2. 用户线程发起IO操作之后立刻可以做其他事情
3. 内核线程收到异步IO之后立刻返回，不会阻塞用户线程
4. 内核线程进行数据准备，完成之后数据复制到用户线程，复制完成之后给用户线程发起完成信号
5. 收到信号用户线程就可以直接使用数据

<div align=center>

![1592478480948.png](..\images\1592478480948.png)

</div>
 
1.1.2	JAVA IO 包 
<div align=center>

![1589098745911.png](..\images\1589098745911.png)

</div>
1.1.1	JAVA NIO 
NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 
<div align=center>

![1589098771832.png](..\images\1589098771832.png)

</div>

NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 
	2.8.2.1. 	NIO 的缓冲区 
 Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 
	2.8.2.2. 	NIO 的非阻塞 
IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 
<div align=center>

![1589098800144.png](..\images\1589098800144.png)

</div>

 
2.8.3. Channel 
首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个
等级的。只不过 Stream 是单向的，譬如：InputStream, OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。 
NIO 中的 Channel 的主要实现有： 
1.	FileChannel 
2.	DatagramChannel 
3.	SocketChannel 
4.	ServerSocketChannel 
这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。
下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。 
2.8.4. Buffer 
Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。 
<div align=center>

![1589098834101.png](..\images\1589098834101.png)

</div>

上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。 
在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、
ShortBuffer 
2.8.5. Selector 
 Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。 
