<!-- TOC -->

- [Java中锁的详解](#java中锁的详解)
  - [背景](#背景)
    - [i--/++分析](#i--分析)
      - [字节码指令](#字节码指令)
    - [临界区 Critical Section](#临界区-critical-section)
    - [竞态条件 Race Condition](#竞态条件-race-condition)
    - [解决方式](#解决方式)
  - [锁分类](#锁分类)
    - [宏观分类](#宏观分类)
      - [乐观锁 （宏观分类）](#乐观锁-宏观分类)
      - [悲观锁（宏观分类）](#悲观锁宏观分类)
    - [公平分类](#公平分类)
      - [非公平锁 （Nonfair）](#非公平锁-nonfair)
      - [公平锁 （Fair）](#公平锁-fair)
  - [锁优化](#锁优化)
    - [偏向锁（偏向第一个获取它的线程，优化锁机制）](#偏向锁偏向第一个获取它的线程优化锁机制)
      - [偏向锁获取过程](#偏向锁获取过程)
      - [偏向锁的撤销](#偏向锁的撤销)
      - [HashCode](#hashcode)
      - [使用场景](#使用场景)
      - [查看停顿–安全点停顿日志](#查看停顿安全点停顿日志)
  - [参考](#参考)

<!-- /TOC -->

# Java中锁的详解

## 背景

在多线程同时访问同一个资源时，如果需要考虑对共享资源的竞争问题以及数据的正确性，这需要引入锁的概念，这就是所谓的线程安全。最常见的场景就是i--操作。

### i--/++分析

#### 字节码指令

```java
getstatic i // 获取静态变量i的值
iconst_1    // 准备常量1
isub        // 自减
putstatic i // 将修改后的值存入静态变量i

getstatic i // 获取静态变量i的值
iconst_1    // 准备常量1
iadd        // 自增
putstatic i // 将修改后的值存入静态变量i
```

<div align=center>

![1590651451164.png](..\images\1590651451164.png)

</div>

### 临界区 Critical Section

1. 一个程序运行多个线程本身是没有问题的
2. 问题出在多个线程访问共享资源
   - 多个线程读共享资源其实也没有问题
   - 在多个线程对共享资源读写操作时发生指令交错，就会出现问题
3. 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区

### 竞态条件 Race Condition

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件

### 解决方式

1. 阻塞：锁（synchronized、lock）
2. 非阻塞：原子化、cas

## 锁分类

### 宏观分类

#### 乐观锁 （宏观分类）

1. 场景：多读少写
2. 思想：读数据时认为数据不会被修改，不加锁；写数据时需要判断数据是否被修改过
3. Java实现：版本控制和CAS
4. CAS说明：一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败）

#### 悲观锁（宏观分类）

1. 场景：写多读少
2. 每次获取数据时都需要加锁，防止被别人修改
3. Java实现：Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 

### 公平分类

#### 非公平锁 （Nonfair）

1. 原理：JVM 按随机、就近原则分配锁
2. ReentrantLock：默认非公平，可以配置为公平
3. 常用：非公平执行效率高于公平锁
4. 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 
   - 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列 
5. Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 

#### 公平锁 （Fair）

1. 先对锁提出获取请求的线程会先被分配到锁
2. ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁
3. 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

## 锁优化

高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，如**适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁膨胀（LockCoarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）** 等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。
**锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。** 

1. 锁升级：随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。 
2. 优化方式
   - 减少锁的持有时间：只用在有线程安全要求的线程上加锁
   - 减小锁粒度 ：偏向锁、分段锁
   - 将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。
   - 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。 
3. 锁分离
   - 读写锁分离，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能
4. 锁粗化 
   - 使用锁的时间尽量短，即时进行释放
   - 防止锁的多次请求、同步和释放
5. 锁消除 锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。 

### 偏向锁（偏向第一个获取它的线程，优化锁机制）

1. 背景：锁在大部分情况下不仅不存在多线程竞争，并且可能会被同一个线程访问多次
2. 目的：消除这个线程锁冲入的开销
3. 优点：减少不必要轻量级锁执行路径（轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗））
4. 轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能
5. 偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了
6. 启动方式：启用参数-XX：+UseBiased Locking，这是自JDK 6起HotSpot虚拟机的默认值

#### 偏向锁获取过程

<div align=center>

![1589109028095.png](..\images\1589109028095.png)

</div>

1. 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中
2. 通过Markword判断是否可偏向（偏向锁标识为1且锁标志为01）
3. 可偏向，判断线程ID是否与当前线程相同，相同则执行代码块
4. 不相同，通过CAS操作竞争锁，成功则设置Markword中threadID为当前线程，并执行代码块
5. 竞争失败（锁升级为轻量级锁），当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word，时间很短

#### 偏向锁的撤销

**一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。** 
根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态

#### HashCode

1. 当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了
2. 而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。
3. 在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。

#### 使用场景

始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作；在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用；

#### 查看停顿–安全点停顿日志

1. 打开安全点日志（不能这一会打开）
   - -XX:+PrintGCApplicationStoppedTime 会打出系统停止的时间，
   - -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1 这两个参数会打印出详细信息，可以查看到使用偏向锁导致的停顿，时间非常短暂，但是争用严重的情况下，停顿次数也会非常多
2. 安全点日志的缺点
   - 安全点日志默认输出到stdout，一是stdout日志的整洁性，二是stdout所重定向的文件如果不在/dev/shm，可能被锁。 
   - 对于一些很短的停顿，比如取消偏向锁，打印的消耗比停顿本身还大。 
   - 安全点日志是在安全点内打印的，本身加大了安全点的停顿时间。
3. 如果在生产系统上要打开，再增加下面四个参数： 
   - -XX:+UnlockDiagnosticVMOptions 
   - -XX: -DisplayVMOutput 
   - -XX:+LogVMOutput 
   - -XX:LogFile=/dev/shm/vm.log 
4. 打开Diagnostic（只是开放了更多的flag可选，不会主动激活某个flag），关掉输出VM日志到stdout，输出到独立文件,/dev/shm目录（内存文件系统）。

<div align=center>

![1589109071755.png](..\images\1589109071755.png)

</div>

此日志分三部分： 
第一部分是时间戳，VM Operation的类型 
第二部分是线程概况，被中括号括起来 
total: 安全点里的总线程数 
initially_running: 安全点开始时正在运行状态的线程数 
wait_to_block: 在VM Operation开始前需要等待其暂停的线程数
第三部分是到达安全点时的各个阶段以及执行操作所花的时间，其中最重要的是vmop
•	spin: 等待线程响应safepoint号召的时间；
•	block: 暂停所有线程所用的时间；
•	sync: 等于 spin+block，这是从开始到进入安全点所耗的时间，可用于判断进入安全点耗时；
•	cleanup: 清理所用时间；
•	vmop: 真正执行VM Operation的时间。
可见，那些很多但又很短的安全点，全都是RevokeBias， 高并发的应用会禁用掉偏向锁。

1.1.1.1	轻量级锁
“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，轻量级锁的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。Java中的轻量级锁依赖于Java对象的头信息。轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。 
轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； 
1.1.1.1.1	轻量级锁加锁过程
1	在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图所示： 
<div align=center>

![1589109098671.png](..\images\1589109098671.png)

</div>


1	拷贝对象头中的Mark Word复制到锁记录中；
2	拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。
如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图所示。 
<div align=center>

![1589109123275.png](..\images\1589109123275.png)

</div>

1	如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

1.1.1.1.1	轻量级锁的释放
释放锁线程视角：由轻量锁切换到重量锁，是发生在轻量锁释放锁的期间，之前在获取锁的时候它拷贝了锁对象头的markword，在释放锁的时候如果它发现在它持有锁的期间有其他线程来尝试获取锁了，并且该线程对markword做了修改，两者比对发现不一致，则切换到重量锁。
因为重量级锁被修改了，所有display mark word和原来的markword不一样了。
怎么补救，就是进入mutex前，compare一下obj的markword状态。确认该markword是否被其他线程持有。
此时如果线程已经释放了markword，那么通过CAS后就可以直接进入线程，无需进入mutex，就这个作用。
尝试获取锁线程视角：如果线程尝试获取锁的时候，轻量锁正被其他线程占有，那么它就会修改markword，修改重量级锁，表示该进入重量锁了。还有一个注意点：等待轻量锁的线程不会阻塞，它会一直自旋等待锁，并如上所说修改markword。这就是自旋锁，尝试获取锁的线程，在没有获得锁的时候，不被挂起，而转而去执行一个空循环，即自旋。在若干个自旋后，如果还没有获得锁，则才被挂起，获得锁，则执行代码。

1.1.1.2	自旋锁 
自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 
线程自旋是需要消耗 cpu的，说白了就是让 cpu在做无用功，如果一直获取不到锁，那线程也不能一直占用 cpu自旋做无用功，所以需要设定一个自旋等待的最大时间。 
如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 
1.1.1.2.1	自旋锁的优缺点 
自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！ 
但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁； 
1.1.1.2.2	自旋锁时间阈值（1.6引入了适应性自旋锁） 
自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！ 
JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化：
	如果平均负载小于 CPUs 则一直自旋，
	如果有超过(CPUs/2) 个线程正在自旋，则后来线程直接阻塞，
	如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，
	如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），
	自旋时会适当放弃线程优先级之间的差异。 
1.1.1.2.3	自旋锁的开启
JDK1.6 中-XX:+UseSpinning 开启；  
-XX:PreBlockSpin=10 为自旋次数；  
JDK1.7 后，去掉此参数，由 jvm 控制； 
1.1.1.3	重量级锁（Mutex Lock） 
Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。 
1.1.1.4	可重入锁（递归锁）
重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。

1.1.1	ReadWriteLock 读写锁  
为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 
读锁 
如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 
写锁 
如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ 
Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现
ReentrantReadWriteLock。 
可以用来实现TreeMap的线程安全使用。
1.1.2	共享锁和独占锁 
java 并发包提供的加锁模式分为独占锁和共享锁。 
独占锁 
独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 
共享锁 
共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 
1.	AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 
2.	java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。 

1.1.3	同步锁与死锁 
1.1.3.1	同步锁 
当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。 
1.1.3.2	死锁 
何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。  

## 参考

1. [Java锁 - 导读](https://www.jianshu.com/p/39628e1180a9)